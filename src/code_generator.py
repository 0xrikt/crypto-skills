"""
Code Generator

Generates runnable trading bot code from strategy configurations.
Supports multiple output formats (standalone Python, Freqtrade, etc.)
"""

from datetime import datetime
from typing import Literal
import json

from .strategy_schema import (
    StrategyConfig,
    ConditionGroup,
    Condition,
    IndicatorType,
    ComparisonOperator
)


class CodeGenerator:
    """Generate executable trading code from strategy configuration"""
    
    def __init__(self, strategy: StrategyConfig):
        """
        Initialize code generator.
        
        Args:
            strategy: Strategy configuration
        """
        self.strategy = strategy
    
    def generate(
        self, 
        output_format: Literal["standalone", "freqtrade", "ccxt_bot"] = "standalone"
    ) -> str:
        """
        Generate trading code.
        
        Args:
            output_format: Target format
                - standalone: Self-contained Python script
                - freqtrade: Freqtrade strategy class
                - ccxt_bot: Simple ccxt-based trading bot
                
        Returns:
            Generated code as string
        """
        if output_format == "standalone":
            return self._generate_standalone()
        elif output_format == "freqtrade":
            return self._generate_freqtrade()
        elif output_format == "ccxt_bot":
            return self._generate_ccxt_bot()
        else:
            raise ValueError(f"Unknown output format: {output_format}")
    
    def _generate_standalone(self) -> str:
        """Generate standalone Python script for backtesting and analysis"""
        
        strategy_json = json.dumps(self.strategy.model_dump(), indent=2, default=str)
        
        code = f'''#!/usr/bin/env python3
"""
{self.strategy.name}

{self.strategy.description}

Generated by Crypto Strategy Backtest Skill
Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Usage:
    python {self._safe_filename()}.py

Requirements:
    pip install pandas numpy ta ccxt plotly
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from typing import Optional
import ccxt
from ta.momentum import RSIIndicator
from ta.trend import MACD, SMAIndicator, EMAIndicator
from ta.volatility import BollingerBands, AverageTrueRange


# ============================================================================
# STRATEGY CONFIGURATION
# ============================================================================

STRATEGY_CONFIG = {strategy_json}


# ============================================================================
# DATA FETCHING
# ============================================================================

def fetch_ohlcv(
    symbol: str = "{self.strategy.symbol}",
    timeframe: str = "{self.strategy.timeframe.value}",
    days: int = 365,
    exchange_id: str = "binance"
) -> pd.DataFrame:
    """Fetch OHLCV data from exchange"""
    
    exchange = getattr(ccxt, exchange_id)({{"enableRateLimit": True}})
    
    end_time = datetime.now()
    start_time = end_time - timedelta(days=days)
    start_ts = int(start_time.timestamp() * 1000)
    end_ts = int(end_time.timestamp() * 1000)
    
    all_candles = []
    current_ts = start_ts
    
    print(f"Fetching {{symbol}} {{timeframe}} data...")
    
    while current_ts < end_ts:
        candles = exchange.fetch_ohlcv(symbol, timeframe, since=current_ts, limit=1000)
        if not candles:
            break
        all_candles.extend(candles)
        current_ts = candles[-1][0] + 1
        
    df = pd.DataFrame(
        all_candles,
        columns=["timestamp", "open", "high", "low", "close", "volume"]
    )
    df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
    df = df.drop_duplicates(subset=["timestamp"]).sort_values("timestamp").reset_index(drop=True)
    
    print(f"Fetched {{len(df)}} candles")
    return df


# ============================================================================
# TECHNICAL INDICATORS
# ============================================================================

def add_indicators(df: pd.DataFrame) -> pd.DataFrame:
    """Add technical indicators to DataFrame"""
    
    result = df.copy()
    
{self._generate_indicator_code()}
    
    return result


# ============================================================================
# SIGNAL GENERATION
# ============================================================================

def generate_entry_signal(df: pd.DataFrame) -> pd.Series:
    """Generate entry signals based on strategy conditions"""
    
{self._generate_signal_code(self.strategy.entry, "entry")}
    
    return signal


def generate_exit_signal(df: pd.DataFrame) -> pd.Series:
    """Generate exit signals based on strategy conditions"""
    
{self._generate_exit_signal_code()}
    
    return signal


# ============================================================================
# BACKTEST ENGINE
# ============================================================================

@dataclass
class Trade:
    entry_time: datetime
    entry_price: float
    quantity: float
    position_size: float
    exit_time: Optional[datetime] = None
    exit_price: Optional[float] = None
    exit_reason: Optional[str] = None
    pnl: float = 0.0
    pnl_percent: float = 0.0


def run_backtest(
    df: pd.DataFrame,
    initial_capital: float = {self.strategy.initial_capital},
    position_size: float = {self.strategy.position_sizing.value},
    stop_loss_pct: float = {self.strategy.exit.stop_loss.value if self.strategy.exit.stop_loss else 0},
    take_profit_pct: float = {self.strategy.exit.take_profit.value if self.strategy.exit.take_profit else 0},
    commission_pct: float = {self.strategy.commission_percent}
) -> tuple[list[Trade], pd.DataFrame]:
    """Run backtest on data"""
    
    capital = initial_capital
    position = None
    trades = []
    equity_history = []
    
    entry_signals = generate_entry_signal(df)
    exit_signals = generate_exit_signal(df)
    
    for idx, row in df.iterrows():
        timestamp = row["timestamp"]
        
        # Check exits first
        if position is not None:
            exit_reason = None
            exit_price = None
            
            # Stop loss
            if stop_loss_pct > 0:
                stop_price = position.entry_price * (1 - stop_loss_pct / 100)
                if row["low"] <= stop_price:
                    exit_reason = "止损"
                    exit_price = stop_price
            
            # Take profit
            if take_profit_pct > 0 and exit_reason is None:
                target_price = position.entry_price * (1 + take_profit_pct / 100)
                if row["high"] >= target_price:
                    exit_reason = "止盈"
                    exit_price = target_price
            
            # Signal exit
            if exit_reason is None and idx in exit_signals.index and exit_signals[idx]:
                exit_reason = "信号出场"
                exit_price = row["close"]
            
            if exit_reason:
                position.exit_time = timestamp
                position.exit_price = exit_price
                position.exit_reason = exit_reason
                gross_pnl = (exit_price - position.entry_price) * position.quantity
                commission = position.position_size * commission_pct / 100 * 2
                position.pnl = gross_pnl - commission
                position.pnl_percent = (position.pnl / position.position_size) * 100
                capital += position.pnl
                trades.append(position)
                position = None
        
        # Check entry
        if position is None and idx in entry_signals.index and entry_signals[idx]:
            entry_price = row["close"]
            quantity = position_size / entry_price
            position = Trade(
                entry_time=timestamp,
                entry_price=entry_price,
                quantity=quantity,
                position_size=position_size
            )
        
        # Record equity
        current_equity = capital
        if position:
            unrealized = (row["close"] - position.entry_price) * position.quantity
            current_equity += unrealized
        
        equity_history.append({{"timestamp": timestamp, "equity": current_equity}})
    
    # Close any open position
    if position:
        last_row = df.iloc[-1]
        position.exit_time = last_row["timestamp"]
        position.exit_price = last_row["close"]
        position.exit_reason = "回测结束"
        gross_pnl = (position.exit_price - position.entry_price) * position.quantity
        commission = position.position_size * commission_pct / 100 * 2
        position.pnl = gross_pnl - commission
        position.pnl_percent = (position.pnl / position.position_size) * 100
        capital += position.pnl
        trades.append(position)
    
    return trades, pd.DataFrame(equity_history)


# ============================================================================
# REPORTING
# ============================================================================

def print_results(trades: list[Trade], equity_df: pd.DataFrame, initial_capital: float):
    """Print backtest results"""
    
    if not trades:
        print("No trades executed")
        return
    
    final_capital = equity_df["equity"].iloc[-1]
    total_return = (final_capital - initial_capital) / initial_capital * 100
    
    wins = [t for t in trades if t.pnl > 0]
    losses = [t for t in trades if t.pnl <= 0]
    win_rate = len(wins) / len(trades) * 100
    
    avg_win = np.mean([t.pnl_percent for t in wins]) if wins else 0
    avg_loss = np.mean([t.pnl_percent for t in losses]) if losses else 0
    
    total_wins = sum(t.pnl for t in wins)
    total_losses = abs(sum(t.pnl for t in losses))
    profit_factor = total_wins / total_losses if total_losses > 0 else float('inf')
    
    # Max drawdown
    equity = equity_df["equity"]
    rolling_max = equity.expanding().max()
    drawdown = (equity - rolling_max) / rolling_max * 100
    max_dd = abs(drawdown.min())
    
    print("\\n" + "=" * 60)
    print(f"  {STRATEGY_CONFIG['name']} - 回测结果")
    print("=" * 60)
    print(f"  初始资金:     ${{initial_capital:,.2f}}")
    print(f"  最终资金:     ${{final_capital:,.2f}}")
    print(f"  总收益率:     {{total_return:+.2f}}%")
    print(f"  最大回撤:     {{max_dd:.2f}}%")
    print("-" * 60)
    print(f"  总交易次数:   {{len(trades)}}")
    print(f"  盈利交易:     {{len(wins)}}")
    print(f"  亏损交易:     {{len(losses)}}")
    print(f"  胜率:         {{win_rate:.1f}}%")
    print(f"  盈利因子:     {{profit_factor:.2f}}")
    print(f"  平均盈利:     {{avg_win:+.2f}}%")
    print(f"  平均亏损:     {{avg_loss:+.2f}}%")
    print("=" * 60)
    
    print("\\n最近 5 笔交易:")
    for trade in trades[-5:]:
        print(f"  {{trade.entry_time.strftime('%Y-%m-%d %H:%M')}} -> "
              f"{{trade.exit_time.strftime('%Y-%m-%d %H:%M')}}: "
              f"{{trade.pnl_percent:+.2f}}% ({{trade.exit_reason}})")


# ============================================================================
# MAIN
# ============================================================================

if __name__ == "__main__":
    # Fetch data
    df = fetch_ohlcv(days=365)
    
    # Add indicators
    df = add_indicators(df)
    
    # Run backtest
    trades, equity_df = run_backtest(df)
    
    # Print results
    print_results(trades, equity_df, {self.strategy.initial_capital})
    
    print("\\n✅ Backtest completed!")
'''
        
        return code
    
    def _generate_freqtrade(self) -> str:
        """Generate Freqtrade strategy class"""
        
        code = f'''"""
{self.strategy.name} - Freqtrade Strategy

{self.strategy.description}

Generated by Crypto Strategy Backtest Skill
Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Usage:
    1. Save this file to user_data/strategies/
    2. Run: freqtrade backtesting --strategy {self._safe_classname()}
"""

from freqtrade.strategy import IStrategy, IntParameter, DecimalParameter
from pandas import DataFrame
import talib.abstract as ta


class {self._safe_classname()}(IStrategy):
    """
    {self.strategy.description}
    """
    
    # Strategy interface version
    INTERFACE_VERSION = 3
    
    # Optimal timeframe for the strategy
    timeframe = "{self.strategy.timeframe.value}"
    
    # Can this strategy go short?
    can_short = False
    
    # Minimal ROI designed for the strategy
    minimal_roi = {{
        "0": {self.strategy.exit.take_profit.value / 100 if self.strategy.exit.take_profit else 0.1}
    }}
    
    # Optimal stoploss
    stoploss = -{self.strategy.exit.stop_loss.value / 100 if self.strategy.exit.stop_loss else 0.03}
    
    # Trailing stop
    trailing_stop = {str(self.strategy.exit.trailing_stop.enabled if self.strategy.exit.trailing_stop else False).lower()}
    trailing_stop_positive = {self.strategy.exit.trailing_stop.value / 100 if self.strategy.exit.trailing_stop and self.strategy.exit.trailing_stop.enabled else 0.01}
    
    # Run "populate_indicators()" only for new candle
    process_only_new_candles = True
    
    # Number of candles the strategy requires before producing valid signals
    startup_candle_count: int = 200
    
{self._generate_freqtrade_parameters()}
    
    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """Add indicators to dataframe"""
        
{self._generate_freqtrade_indicators()}
        
        return dataframe
    
    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """Define entry conditions"""
        
        dataframe.loc[
{self._generate_freqtrade_entry_conditions()}
            ,
            'enter_long'
        ] = 1
        
        return dataframe
    
    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """Define exit conditions"""
        
        dataframe.loc[
{self._generate_freqtrade_exit_conditions()}
            ,
            'exit_long'
        ] = 1
        
        return dataframe
'''
        
        return code
    
    def _generate_ccxt_bot(self) -> str:
        """Generate simple ccxt-based trading bot"""
        
        code = f'''#!/usr/bin/env python3
"""
{self.strategy.name} - Live Trading Bot

{self.strategy.description}

Generated by Crypto Strategy Backtest Skill
Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

⚠️  WARNING: This is for educational purposes only!
    - Always test with small amounts first
    - Use proper risk management
    - Never risk more than you can afford to lose

Usage:
    1. Set your API keys as environment variables:
       export EXCHANGE_API_KEY="your_api_key"
       export EXCHANGE_SECRET="your_secret"
    
    2. Run: python {self._safe_filename()}_bot.py
"""

import os
import time
import logging
from datetime import datetime, timedelta
from typing import Optional

import ccxt
import pandas as pd
import numpy as np
from ta.momentum import RSIIndicator
from ta.trend import MACD, SMAIndicator, EMAIndicator
from ta.volatility import BollingerBands, AverageTrueRange


# ============================================================================
# CONFIGURATION
# ============================================================================

CONFIG = {{
    "symbol": "{self.strategy.symbol}",
    "timeframe": "{self.strategy.timeframe.value}",
    "exchange": "binance",
    "position_size": {self.strategy.position_sizing.value},  # USDT
    "stop_loss_pct": {self.strategy.exit.stop_loss.value if self.strategy.exit.stop_loss else 3.0},
    "take_profit_pct": {self.strategy.exit.take_profit.value if self.strategy.exit.take_profit else 6.0},
    "check_interval_seconds": 60,  # How often to check signals
    "dry_run": True,  # Set to False for live trading
}}


# ============================================================================
# LOGGING
# ============================================================================

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler("trading_bot.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


# ============================================================================
# EXCHANGE SETUP
# ============================================================================

def create_exchange():
    """Create and configure exchange instance"""
    
    api_key = os.environ.get("EXCHANGE_API_KEY", "")
    secret = os.environ.get("EXCHANGE_SECRET", "")
    
    if not api_key or not secret:
        logger.warning("API credentials not found. Running in read-only mode.")
    
    exchange = ccxt.binance({{
        "apiKey": api_key,
        "secret": secret,
        "enableRateLimit": True,
        "options": {{"defaultType": "spot"}}
    }})
    
    return exchange


# ============================================================================
# DATA & INDICATORS
# ============================================================================

def fetch_recent_data(exchange, symbol: str, timeframe: str, limit: int = 200) -> pd.DataFrame:
    """Fetch recent OHLCV data"""
    
    candles = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
    
    df = pd.DataFrame(
        candles,
        columns=["timestamp", "open", "high", "low", "close", "volume"]
    )
    df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
    
    return df


def add_indicators(df: pd.DataFrame) -> pd.DataFrame:
    """Add technical indicators"""
    
    result = df.copy()
    
{self._generate_indicator_code()}
    
    return result


# ============================================================================
# SIGNAL LOGIC
# ============================================================================

def check_entry_signal(df: pd.DataFrame) -> bool:
    """Check if entry conditions are met"""
    
    if len(df) < 2:
        return False
    
    current = df.iloc[-1]
    previous = df.iloc[-2]
    
{self._generate_bot_entry_conditions()}
    
    return entry_signal


def check_exit_signal(df: pd.DataFrame, entry_price: float) -> tuple[bool, str]:
    """Check if exit conditions are met"""
    
    current = df.iloc[-1]
    current_price = current["close"]
    
    # Stop loss
    stop_price = entry_price * (1 - CONFIG["stop_loss_pct"] / 100)
    if current_price <= stop_price:
        return True, "止损"
    
    # Take profit
    target_price = entry_price * (1 + CONFIG["take_profit_pct"] / 100)
    if current_price >= target_price:
        return True, "止盈"
    
    # Signal exit
{self._generate_bot_exit_conditions()}
    
    return False, ""


# ============================================================================
# TRADING LOGIC
# ============================================================================

class TradingBot:
    def __init__(self, exchange, config: dict):
        self.exchange = exchange
        self.config = config
        self.position = None  # {{"entry_price": float, "quantity": float, "entry_time": datetime}}
        
    def get_balance(self, currency: str = "USDT") -> float:
        """Get available balance"""
        if self.config["dry_run"]:
            return 10000.0
        
        balance = self.exchange.fetch_balance()
        return balance.get(currency, {{}}).get("free", 0)
    
    def place_order(self, side: str, amount: float, price: Optional[float] = None):
        """Place an order"""
        symbol = self.config["symbol"]
        
        if self.config["dry_run"]:
            logger.info(f"[DRY RUN] {{side.upper()}} {{amount:.6f}} {{symbol}} @ {{price or 'market'}}")
            return {{"id": "dry_run", "price": price}}
        
        if side == "buy":
            order = self.exchange.create_market_buy_order(symbol, amount)
        else:
            order = self.exchange.create_market_sell_order(symbol, amount)
        
        logger.info(f"Order placed: {{order}}")
        return order
    
    def run(self):
        """Main trading loop"""
        
        logger.info(f"Starting trading bot for {{self.config['symbol']}}")
        logger.info(f"Dry run mode: {{self.config['dry_run']}}")
        
        while True:
            try:
                # Fetch data
                df = fetch_recent_data(
                    self.exchange,
                    self.config["symbol"],
                    self.config["timeframe"]
                )
                df = add_indicators(df)
                
                current_price = df.iloc[-1]["close"]
                
                # Check position and signals
                if self.position is None:
                    # Check entry
                    if check_entry_signal(df):
                        # Calculate position size
                        balance = self.get_balance()
                        position_size = min(self.config["position_size"], balance * 0.95)
                        quantity = position_size / current_price
                        
                        # Place buy order
                        self.place_order("buy", quantity, current_price)
                        
                        self.position = {{
                            "entry_price": current_price,
                            "quantity": quantity,
                            "entry_time": datetime.now()
                        }}
                        
                        logger.info(f"ENTRY: Bought {{quantity:.6f}} @ {{current_price:.2f}}")
                
                else:
                    # Check exit
                    should_exit, reason = check_exit_signal(df, self.position["entry_price"])
                    
                    if should_exit:
                        # Place sell order
                        self.place_order("sell", self.position["quantity"], current_price)
                        
                        pnl = (current_price - self.position["entry_price"]) * self.position["quantity"]
                        pnl_pct = (current_price / self.position["entry_price"] - 1) * 100
                        
                        logger.info(f"EXIT ({{reason}}): Sold @ {{current_price:.2f}}, PnL: ${{pnl:.2f}} ({{pnl_pct:+.2f}}%)")
                        
                        self.position = None
                
                # Log status
                status = "IN POSITION" if self.position else "WAITING"
                logger.info(f"[{{status}}] Price: {{current_price:.2f}}")
                
            except Exception as e:
                logger.error(f"Error in trading loop: {{e}}")
            
            # Wait before next check
            time.sleep(self.config["check_interval_seconds"])


# ============================================================================
# MAIN
# ============================================================================

if __name__ == "__main__":
    logger.info("=" * 60)
    logger.info("  {self.strategy.name}")
    logger.info("  Trading Bot Starting...")
    logger.info("=" * 60)
    
    exchange = create_exchange()
    bot = TradingBot(exchange, CONFIG)
    
    try:
        bot.run()
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
'''
        
        return code
    
    def _safe_filename(self) -> str:
        """Convert strategy name to safe filename"""
        return "".join(c if c.isalnum() else "_" for c in self.strategy.name.lower())
    
    def _safe_classname(self) -> str:
        """Convert strategy name to safe class name"""
        words = self.strategy.name.replace("-", " ").replace("_", " ").split()
        return "".join(word.capitalize() for word in words if word.isalnum() or word == "")
    
    def _generate_indicator_code(self) -> str:
        """Generate indicator calculation code"""
        lines = []
        added = set()
        
        # Collect all indicators
        for cond in self.strategy.entry.conditions:
            self._add_indicator_code(cond.indicator, cond.params, lines, added)
            if cond.value_indicator:
                self._add_indicator_code(cond.value_indicator, cond.value_indicator_params, lines, added)
        
        if self.strategy.exit.conditions:
            for cond in self.strategy.exit.conditions.conditions:
                self._add_indicator_code(cond.indicator, cond.params, lines, added)
                if cond.value_indicator:
                    self._add_indicator_code(cond.value_indicator, cond.value_indicator_params, lines, added)
        
        return "\n".join(f"    {line}" for line in lines)
    
    def _add_indicator_code(self, ind_type: IndicatorType, params, lines: list, added: set):
        """Add indicator calculation code"""
        if params is None:
            params = type('obj', (object,), {'period': 14, 'fast_period': 12, 'slow_period': 26, 'signal_period': 9, 'std_dev': 2.0})()
        
        key = f"{ind_type.value}_{params.period if hasattr(params, 'period') else ''}"
        if key in added:
            return
        added.add(key)
        
        if ind_type == IndicatorType.RSI:
            period = params.period or 14
            lines.append(f'# RSI')
            lines.append(f'rsi_indicator = RSIIndicator(close=result["close"], window={period})')
            lines.append(f'result["RSI_{period}"] = rsi_indicator.rsi()')
        
        elif ind_type in [IndicatorType.MACD, IndicatorType.MACD_SIGNAL, IndicatorType.MACD_HIST]:
            fast = params.fast_period or 12
            slow = params.slow_period or 26
            signal = params.signal_period or 9
            macd_key = f"MACD_{fast}_{slow}_{signal}"
            if macd_key not in added:
                added.add(macd_key)
                lines.append(f'# MACD')
                lines.append(f'macd_indicator = MACD(close=result["close"], window_fast={fast}, window_slow={slow}, window_sign={signal})')
                lines.append(f'result["MACD_{fast}_{slow}_{signal}"] = macd_indicator.macd()')
                lines.append(f'result["MACD_SIGNAL_{fast}_{slow}_{signal}"] = macd_indicator.macd_signal()')
                lines.append(f'result["MACD_HIST_{fast}_{slow}_{signal}"] = macd_indicator.macd_diff()')
        
        elif ind_type == IndicatorType.SMA:
            period = params.period or 20
            lines.append(f'# SMA')
            lines.append(f'sma_indicator = SMAIndicator(close=result["close"], window={period})')
            lines.append(f'result["SMA_{period}"] = sma_indicator.sma_indicator()')
        
        elif ind_type == IndicatorType.EMA:
            period = params.period or 20
            lines.append(f'# EMA')
            lines.append(f'ema_indicator = EMAIndicator(close=result["close"], window={period})')
            lines.append(f'result["EMA_{period}"] = ema_indicator.ema_indicator()')
        
        elif ind_type in [IndicatorType.BBANDS_UPPER, IndicatorType.BBANDS_MIDDLE, IndicatorType.BBANDS_LOWER]:
            period = params.period or 20
            std = params.std_dev or 2.0
            bb_key = f"BB_{period}"
            if bb_key not in added:
                added.add(bb_key)
                lines.append(f'# Bollinger Bands')
                lines.append(f'bb_indicator = BollingerBands(close=result["close"], window={period}, window_dev={std})')
                lines.append(f'result["BB_UPPER_{period}"] = bb_indicator.bollinger_hband()')
                lines.append(f'result["BB_MIDDLE_{period}"] = bb_indicator.bollinger_mavg()')
                lines.append(f'result["BB_LOWER_{period}"] = bb_indicator.bollinger_lband()')
        
        elif ind_type == IndicatorType.ATR:
            period = params.period or 14
            lines.append(f'# ATR')
            lines.append(f'atr_indicator = AverageTrueRange(high=result["high"], low=result["low"], close=result["close"], window={period})')
            lines.append(f'result["ATR_{period}"] = atr_indicator.average_true_range()')
    
    def _generate_signal_code(self, group: ConditionGroup, name: str) -> str:
        """Generate signal generation code"""
        conditions = []
        
        for cond in group.conditions:
            cond_str = self._condition_to_code(cond)
            conditions.append(cond_str)
        
        if group.logic.value == "AND":
            combined = " & ".join(f"({c})" for c in conditions)
        else:
            combined = " | ".join(f"({c})" for c in conditions)
        
        return f"    signal = {combined}"
    
    def _condition_to_code(self, cond: Condition) -> str:
        """Convert a condition to code"""
        params = cond.params
        if params is None:
            params = type('obj', (object,), {'period': 14, 'fast_period': 12, 'slow_period': 26, 'signal_period': 9, 'std_dev': 2.0})()
        
        # Get column name
        if cond.indicator == IndicatorType.RSI:
            col = f'df["RSI_{params.period or 14}"]'
        elif cond.indicator == IndicatorType.MACD:
            col = f'df["MACD_{params.fast_period or 12}_{params.slow_period or 26}_{params.signal_period or 9}"]'
        elif cond.indicator == IndicatorType.MACD_SIGNAL:
            col = f'df["MACD_SIGNAL_{params.fast_period or 12}_{params.slow_period or 26}_{params.signal_period or 9}"]'
        elif cond.indicator == IndicatorType.SMA:
            col = f'df["SMA_{params.period or 20}"]'
        elif cond.indicator == IndicatorType.EMA:
            col = f'df["EMA_{params.period or 20}"]'
        elif cond.indicator == IndicatorType.PRICE:
            col = 'df["close"]'
        else:
            col = f'df["{cond.indicator.value}"]'
        
        # Get comparison value
        if cond.value is not None:
            compare = str(cond.value)
        elif cond.value_indicator:
            vparams = cond.value_indicator_params
            if vparams is None:
                vparams = type('obj', (object,), {'period': 14, 'fast_period': 12, 'slow_period': 26, 'signal_period': 9})()
            
            if cond.value_indicator == IndicatorType.MACD_SIGNAL:
                compare = f'df["MACD_SIGNAL_{vparams.fast_period or 12}_{vparams.slow_period or 26}_{vparams.signal_period or 9}"]'
            else:
                compare = f'df["{cond.value_indicator.value}"]'
        else:
            compare = "0"
        
        # Generate condition
        op = cond.operator
        if op == ComparisonOperator.GT:
            return f"{col} > {compare}"
        elif op == ComparisonOperator.GTE:
            return f"{col} >= {compare}"
        elif op == ComparisonOperator.LT:
            return f"{col} < {compare}"
        elif op == ComparisonOperator.LTE:
            return f"{col} <= {compare}"
        elif op == ComparisonOperator.CROSS_ABOVE:
            return f"({col}.shift(1) <= {compare}.shift(1)) & ({col} > {compare})"
        elif op == ComparisonOperator.CROSS_BELOW:
            return f"({col}.shift(1) >= {compare}.shift(1)) & ({col} < {compare})"
        
        return "True"
    
    def _generate_exit_signal_code(self) -> str:
        """Generate exit signal code"""
        if self.strategy.exit.conditions:
            return self._generate_signal_code(self.strategy.exit.conditions, "exit")
        return "    signal = pd.Series(False, index=df.index)"
    
    def _generate_freqtrade_parameters(self) -> str:
        """Generate Freqtrade hyperopt parameters"""
        lines = []
        lines.append("    # Hyperopt parameters")
        
        for cond in self.strategy.entry.conditions:
            if cond.indicator == IndicatorType.RSI and cond.value:
                lines.append(f"    rsi_buy_threshold = IntParameter(20, 40, default={int(cond.value)}, space='buy')")
        
        return "\n".join(lines)
    
    def _generate_freqtrade_indicators(self) -> str:
        """Generate Freqtrade indicator code"""
        lines = []
        added = set()
        
        for cond in self.strategy.entry.conditions:
            self._add_freqtrade_indicator(cond.indicator, cond.params, lines, added)
        
        if self.strategy.exit.conditions:
            for cond in self.strategy.exit.conditions.conditions:
                self._add_freqtrade_indicator(cond.indicator, cond.params, lines, added)
        
        return "\n".join(f"        {line}" for line in lines)
    
    def _add_freqtrade_indicator(self, ind_type: IndicatorType, params, lines: list, added: set):
        """Add Freqtrade indicator code"""
        if params is None:
            params = type('obj', (object,), {'period': 14, 'fast_period': 12, 'slow_period': 26, 'signal_period': 9})()
        
        key = ind_type.value
        if key in added:
            return
        added.add(key)
        
        if ind_type == IndicatorType.RSI:
            period = params.period or 14
            lines.append(f'dataframe["rsi"] = ta.RSI(dataframe, timeperiod={period})')
        elif ind_type in [IndicatorType.MACD, IndicatorType.MACD_SIGNAL]:
            fast = params.fast_period or 12
            slow = params.slow_period or 26
            signal = params.signal_period or 9
            lines.append(f'macd = ta.MACD(dataframe, fastperiod={fast}, slowperiod={slow}, signalperiod={signal})')
            lines.append('dataframe["macd"] = macd["macd"]')
            lines.append('dataframe["macdsignal"] = macd["macdsignal"]')
    
    def _generate_freqtrade_entry_conditions(self) -> str:
        """Generate Freqtrade entry conditions"""
        conditions = []
        
        for cond in self.strategy.entry.conditions:
            cond_str = self._condition_to_freqtrade(cond)
            if cond_str:
                conditions.append(cond_str)
        
        if not conditions:
            return "            (dataframe['volume'] > 0)"
        
        return " &\n".join(f"            ({c})" for c in conditions)
    
    def _generate_freqtrade_exit_conditions(self) -> str:
        """Generate Freqtrade exit conditions"""
        if not self.strategy.exit.conditions:
            return "            (dataframe['volume'] > 0)  # Placeholder"
        
        conditions = []
        for cond in self.strategy.exit.conditions.conditions:
            cond_str = self._condition_to_freqtrade(cond)
            if cond_str:
                conditions.append(cond_str)
        
        if not conditions:
            return "            (dataframe['volume'] > 0)"
        
        logic = " & " if self.strategy.exit.conditions.logic.value == "AND" else " | "
        return logic.join(f"            ({c})" for c in conditions)
    
    def _condition_to_freqtrade(self, cond: Condition) -> str:
        """Convert condition to Freqtrade format"""
        if cond.indicator == IndicatorType.RSI:
            if cond.operator == ComparisonOperator.LT:
                return f'dataframe["rsi"] < {cond.value}'
            elif cond.operator == ComparisonOperator.GT:
                return f'dataframe["rsi"] > {cond.value}'
        elif cond.indicator == IndicatorType.MACD:
            if cond.operator == ComparisonOperator.CROSS_ABOVE:
                return 'qtpylib.crossed_above(dataframe["macd"], dataframe["macdsignal"])'
            elif cond.operator == ComparisonOperator.CROSS_BELOW:
                return 'qtpylib.crossed_below(dataframe["macd"], dataframe["macdsignal"])'
        
        return ""
    
    def _generate_bot_entry_conditions(self) -> str:
        """Generate entry condition checks for bot"""
        checks = []
        
        for cond in self.strategy.entry.conditions:
            check = self._condition_to_bot_check(cond, "current", "previous")
            if check:
                checks.append(check)
        
        if not checks:
            return "    entry_signal = False"
        
        logic = " and " if self.strategy.entry.logic.value == "AND" else " or "
        combined = logic.join(checks)
        
        return f"    entry_signal = {combined}"
    
    def _generate_bot_exit_conditions(self) -> str:
        """Generate exit condition checks for bot"""
        if not self.strategy.exit.conditions:
            return "    signal_exit = False"
        
        checks = []
        for cond in self.strategy.exit.conditions.conditions:
            check = self._condition_to_bot_check(cond, "current", None)
            if check:
                checks.append(check)
        
        if not checks:
            return "    signal_exit = False"
        
        logic = " and " if self.strategy.exit.conditions.logic.value == "AND" else " or "
        combined = logic.join(checks)
        
        return f"""    signal_exit = {combined}
    if signal_exit:
        return True, "信号出场\""""
    
    def _condition_to_bot_check(self, cond: Condition, current_var: str, prev_var: str = None) -> str:
        """Convert condition to bot check code"""
        params = cond.params
        if params is None:
            params = type('obj', (object,), {'period': 14, 'fast_period': 12, 'slow_period': 26, 'signal_period': 9})()
        
        # Get column name
        if cond.indicator == IndicatorType.RSI:
            col = f'RSI_{params.period or 14}'
        elif cond.indicator == IndicatorType.MACD:
            col = f'MACD_{params.fast_period or 12}_{params.slow_period or 26}_{params.signal_period or 9}'
        elif cond.indicator == IndicatorType.MACD_SIGNAL:
            col = f'MACD_SIGNAL_{params.fast_period or 12}_{params.slow_period or 26}_{params.signal_period or 9}'
        else:
            col = cond.indicator.value.lower()
        
        val = f'{current_var}["{col}"]'
        
        if cond.value is not None:
            compare = str(cond.value)
        elif cond.value_indicator:
            vparams = cond.value_indicator_params
            if vparams is None:
                vparams = type('obj', (object,), {'period': 14, 'fast_period': 12, 'slow_period': 26, 'signal_period': 9})()
            if cond.value_indicator == IndicatorType.MACD_SIGNAL:
                compare = f'{current_var}["MACD_SIGNAL_{vparams.fast_period or 12}_{vparams.slow_period or 26}_{vparams.signal_period or 9}"]'
            else:
                compare = f'{current_var}["{cond.value_indicator.value.lower()}"]'
        else:
            return ""
        
        op = cond.operator
        if op == ComparisonOperator.LT:
            return f"{val} < {compare}"
        elif op == ComparisonOperator.GT:
            return f"{val} > {compare}"
        elif op == ComparisonOperator.CROSS_ABOVE and prev_var:
            prev_val = f'{prev_var}["{col}"]'
            if cond.value_indicator:
                prev_compare = compare.replace(current_var, prev_var)
            else:
                prev_compare = compare
            return f"({prev_val} <= {prev_compare} and {val} > {compare})"
        
        return ""


def save_strategy_code(strategy: StrategyConfig, output_dir: str = ".") -> dict:
    """
    Save all code formats for a strategy.
    
    Args:
        strategy: Strategy configuration
        output_dir: Directory to save files
        
    Returns:
        Dictionary with file paths
    """
    import os
    os.makedirs(output_dir, exist_ok=True)
    
    generator = CodeGenerator(strategy)
    
    files = {}
    
    # Standalone backtest script
    standalone = generator.generate("standalone")
    path = os.path.join(output_dir, f"{generator._safe_filename()}.py")
    with open(path, "w", encoding="utf-8") as f:
        f.write(standalone)
    files["standalone"] = path
    
    # Freqtrade strategy
    freqtrade = generator.generate("freqtrade")
    path = os.path.join(output_dir, f"{generator._safe_classname()}.py")
    with open(path, "w", encoding="utf-8") as f:
        f.write(freqtrade)
    files["freqtrade"] = path
    
    # CCXT bot
    bot = generator.generate("ccxt_bot")
    path = os.path.join(output_dir, f"{generator._safe_filename()}_bot.py")
    with open(path, "w", encoding="utf-8") as f:
        f.write(bot)
    files["ccxt_bot"] = path
    
    return files


if __name__ == "__main__":
    from .strategy_schema import EXAMPLE_STRATEGY
    
    strategy = StrategyConfig(**EXAMPLE_STRATEGY)
    generator = CodeGenerator(strategy)
    
    # Generate standalone code
    code = generator.generate("standalone")
    print("=" * 60)
    print("STANDALONE BACKTEST SCRIPT")
    print("=" * 60)
    print(code[:2000] + "\n...[truncated]...")
